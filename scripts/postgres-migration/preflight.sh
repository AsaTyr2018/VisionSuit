#!/usr/bin/env bash
set -euo pipefail

# VisionSuit PostgreSQL migration preflight agent.
#
# The preflight stage consumes the vs-conf.txt bundle generated by the remote
# postgress-prepare.sh script. It verifies SSH connectivity, confirms the target
# PostgreSQL database is reachable, and writes a `.env-migration` file in the
# repository root that downstream migration helpers consume.

CONFIG_FILE=""
ENV_MIGRATION_FILE=".env-migration"
SSH_KEY_PATH="config/migration-ssh-key"
SYSTEM_SSH_DIR="${HOME}/.ssh"
SYSTEM_SSH_KEY_PATH="${SYSTEM_SSH_DIR}/visionsuit-migration"
SYSTEM_SSH_AGENT_ENV="${SYSTEM_SSH_DIR}/visionsuit-migration-agent.env"
SSH_AGENT_STARTED=0
SSH_TUNNEL_PID=""
SQLITE_PATH="backend/prisma/dev.db"

usage() {
  cat <<USAGE
Usage: $0 --config /root/config/vs-conf.txt [--sqlite backend/prisma/dev.db]

Options:
  --config <path>    Path to the configuration bundle copied from the target host (required)
  --sqlite <path>    Path to the source SQLite database (default: backend/prisma/dev.db)
  --env <path>       Destination for the generated migration env file (default: ./.env-migration)
  --ssh-key <path>   Where to write the extracted SSH private key (default: config/migration-ssh-key)
  -h, --help         Show this help message
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --config)
      CONFIG_FILE="$2"
      shift 2
      ;;
    --sqlite)
      SQLITE_PATH="$2"
      shift 2
      ;;
    --env)
      ENV_MIGRATION_FILE="$2"
      shift 2
      ;;
    --ssh-key)
      SSH_KEY_PATH="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "[preflight] Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ -z "$CONFIG_FILE" ]]; then
  echo "[preflight] --config is required." >&2
  usage
  exit 1
fi

if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "[preflight] Configuration file '$CONFIG_FILE' not found." >&2
  exit 1
fi

mkdir -p "$(dirname "$SSH_KEY_PATH")"

parse_conf() {
  local key="$1"
  awk -F'=' -v "k=$key" '$1==k {print substr($0, index($0,"=")+1)}' "$CONFIG_FILE"
}

SSH_HOST="$(parse_conf SSH_HOST)"
SSH_PORT="$(parse_conf SSH_PORT)"
SSH_USER="$(parse_conf SSH_USER)"
SSH_KEY_B64="$(parse_conf SSH_PRIVATE_KEY_BASE64)"
POSTGRES_HOST="$(parse_conf POSTGRES_HOST)"
POSTGRES_PORT="$(parse_conf POSTGRES_PORT)"
POSTGRES_DB="$(parse_conf POSTGRES_DB)"
POSTGRES_USER="$(parse_conf POSTGRES_USER)"
POSTGRES_PASSWORD="$(parse_conf POSTGRES_PASSWORD)"
POSTGRES_SUPERUSER="$(parse_conf POSTGRES_SUPERUSER)"
POSTGRES_INTERNAL_HOST="$(parse_conf POSTGRES_INTERNAL_HOST)"

for key in SSH_HOST SSH_PORT SSH_USER SSH_KEY_B64 POSTGRES_HOST POSTGRES_PORT POSTGRES_DB POSTGRES_USER POSTGRES_PASSWORD POSTGRES_SUPERUSER POSTGRES_INTERNAL_HOST; do
  if [[ -z "${!key:-}" ]]; then
    echo "[preflight] Missing required value for $key in ${CONFIG_FILE}." >&2
    exit 1
  fi
done

if ! [[ "$SSH_PORT" =~ ^[0-9]+$ ]]; then
  echo "[preflight] SSH_PORT must be numeric." >&2
  exit 1
fi

echo "$SSH_KEY_B64" | base64 -d >"$SSH_KEY_PATH"
chmod 600 "$SSH_KEY_PATH"

install -d -m 700 "$SYSTEM_SSH_DIR"
cp -f "$SSH_KEY_PATH" "$SYSTEM_SSH_KEY_PATH"
chmod 600 "$SYSTEM_SSH_KEY_PATH"

if ! command -v ssh-add >/dev/null 2>&1; then
  echo "[preflight] ssh-add is required to load the SSH key into the system agent." >&2
  exit 1
fi

if ! command -v ssh-agent >/dev/null 2>&1; then
  echo "[preflight] ssh-agent is required to load the SSH key into the system agent." >&2
  exit 1
fi

SSH_CMD=(ssh -i "$SSH_KEY_PATH" -p "$SSH_PORT" -o BatchMode=yes -o StrictHostKeyChecking=accept-new)

if [[ -z "${SSH_AUTH_SOCK:-}" ]] || ! ssh-add -l >/dev/null 2>&1; then
  eval "$(ssh-agent -s)" >/dev/null
  SSH_AGENT_STARTED=1
fi

if ! ssh-add -q "$SYSTEM_SSH_KEY_PATH"; then
  echo "[preflight] Failed to add SSH key to ssh-agent." >&2
  exit 1
fi

if [[ ${SSH_AGENT_STARTED} -eq 1 ]]; then
  cat >"$SYSTEM_SSH_AGENT_ENV" <<ENV
# Autogenerated by scripts/postgres-migration/preflight.sh
export SSH_AUTH_SOCK=${SSH_AUTH_SOCK}
export SSH_AGENT_PID=${SSH_AGENT_PID:-}
ENV
  chmod 600 "$SYSTEM_SSH_AGENT_ENV"
  AGENT_MESSAGE="New ssh-agent started; source ${SYSTEM_SSH_AGENT_ENV} in future shells to reuse it."
elif [[ -n "${SSH_AUTH_SOCK:-}" ]]; then
  cat >"$SYSTEM_SSH_AGENT_ENV" <<ENV
# Autogenerated by scripts/postgres-migration/preflight.sh
export SSH_AUTH_SOCK=${SSH_AUTH_SOCK}
export SSH_AGENT_PID=${SSH_AGENT_PID:-}
ENV
  chmod 600 "$SYSTEM_SSH_AGENT_ENV"
  AGENT_MESSAGE="Existing ssh-agent detected; refreshed ${SYSTEM_SSH_AGENT_ENV} with the active environment variables."
else
  AGENT_MESSAGE="SSH agent environment not detected; key available on disk for direct ssh usage."
fi

cleanup() {
  if [[ -n "${SSH_TUNNEL_PID:-}" ]]; then
    kill "$SSH_TUNNEL_PID" 2>/dev/null || true
  fi
}

log() {
  printf '[preflight] %s\n' "$1"
}

run_with_sudo() {
  if [[ $EUID -eq 0 ]]; then
    "$@"
    return $?
  fi

  if command -v sudo >/dev/null 2>&1; then
    sudo "$@"
    return $?
  fi

  echo "[preflight] Cannot escalate privileges to install packages. Run as root or install dependencies manually." >&2
  return 1
}

PKG_MANAGER=""
APT_UPDATED=0

detect_package_manager() {
  if [[ -n "$PKG_MANAGER" ]]; then
    return
  fi

  if command -v apt-get >/dev/null 2>&1; then
    PKG_MANAGER="apt"
  elif command -v dnf >/dev/null 2>&1; then
    PKG_MANAGER="dnf"
  elif command -v yum >/dev/null 2>&1; then
    PKG_MANAGER="yum"
  elif command -v pacman >/dev/null 2>&1; then
    PKG_MANAGER="pacman"
  elif command -v brew >/dev/null 2>&1; then
    PKG_MANAGER="brew"
  else
    PKG_MANAGER=""
  fi
}

install_package() {
  local package="$1"

  detect_package_manager

  case "$PKG_MANAGER" in
    apt)
      if [[ $APT_UPDATED -eq 0 ]]; then
        if ! run_with_sudo apt-get update -y >/dev/null; then
          return 1
        fi
        APT_UPDATED=1
      fi
      run_with_sudo apt-get install -y "$package"
      ;;
    dnf)
      run_with_sudo dnf install -y "$package"
      ;;
    yum)
      run_with_sudo yum install -y "$package"
      ;;
    pacman)
      run_with_sudo pacman -Sy --noconfirm "$package"
      ;;
    brew)
      brew install "$package"
      ;;
    *)
      return 1
      ;;
  esac
}

ensure_dependency() {
  local tool="$1"
  shift

  if command -v "$tool" >/dev/null 2>&1; then
    return 0
  fi

  log "$tool not found; attempting automatic installation."

  detect_package_manager
  if [[ -z "$PKG_MANAGER" ]]; then
    echo "[preflight] No supported package manager detected. Install ${tool} manually and rerun preflight." >&2
    return 1
  fi

  local package=""
  for mapping in "$@"; do
    if [[ "$mapping" == "$PKG_MANAGER="* ]]; then
      package="${mapping#*=}"
      break
    fi
  done

  if [[ -z "$package" ]]; then
    echo "[preflight] Automatic installation for ${tool} is not configured for ${PKG_MANAGER}. Install it manually." >&2
    return 1
  fi

  if install_package "$package"; then
    if command -v "$tool" >/dev/null 2>&1; then
      log "Installed ${tool} via ${PKG_MANAGER}."
      return 0
    fi
  fi

  echo "[preflight] Failed to install ${tool} automatically. Install it manually and rerun preflight." >&2
  return 1
}

log "Validating local migration dependencies."

HAS_PGLOADER=0
if ensure_dependency "pgloader" \
  "apt=pgloader" "dnf=pgloader" "yum=pgloader" "pacman=pgloader" "brew=pgloader"; then
  HAS_PGLOADER=1
  log "pgloader ready for primary SQLite â†’ PostgreSQL transfer."
else
  log "pgloader remains unavailable after automatic installation attempt; sqlite3 fallback will be required." >&2
fi

HAS_SQLITE=0
if ensure_dependency "sqlite3" \
  "apt=sqlite3" "dnf=sqlite" "yum=sqlite" "pacman=sqlite" "brew=sqlite"; then
  HAS_SQLITE=1
  log "sqlite3 ready for migration fallback and export tooling."
else
  log "sqlite3 remains unavailable after automatic installation attempt." >&2
fi

if [[ ${HAS_PGLOADER} -eq 0 && ${HAS_SQLITE} -eq 0 ]]; then
  echo "[preflight] Neither pgloader nor sqlite3 is available. Install pgloader (preferred) or sqlite3 before continuing." >&2
  exit 1
fi

log "SSH private key extracted to ${SSH_KEY_PATH}, installed at ${SYSTEM_SSH_KEY_PATH}, and loaded into ssh-agent. ${AGENT_MESSAGE}"

log "Checking SSH connectivity to ${SSH_USER}@${SSH_HOST}:${SSH_PORT}."
if ! "${SSH_CMD[@]}" "${SSH_USER}@${SSH_HOST}" 'echo preflight-ok' >/dev/null; then
  echo "[preflight] SSH connectivity test failed." >&2
  exit 1
fi

log "Ensuring PostgreSQL role ${POSTGRES_USER} exists with the configured password."
if ! "${SSH_CMD[@]}" \
  "${SSH_USER}@${SSH_HOST}" \
  ROLE="$POSTGRES_USER" PASSWORD="$POSTGRES_PASSWORD" PORT="$POSTGRES_PORT" SUPER="$POSTGRES_SUPERUSER" \
  bash -s <<'EOS'; then
set -euo pipefail
sudo -u "$SUPER" psql -v ON_ERROR_STOP=1 -p "$PORT" -d postgres -v role="$ROLE" -v pwd="$PASSWORD" <<'SQL'
DO $do$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'role') THEN
    EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', :'role', :'pwd');
  ELSE
    EXECUTE format('ALTER ROLE %I WITH LOGIN PASSWORD %L', :'role', :'pwd');
  END IF;
END
$do$;
SQL
EOS
  echo "[preflight] Failed to provision or update PostgreSQL role ${POSTGRES_USER}." >&2
  exit 1
fi

log "PostgreSQL role ${POSTGRES_USER} confirmed."

log "Validating PostgreSQL connection from target host via SSH tunnel."

if ! command -v psql >/dev/null 2>&1; then
  echo "[preflight] psql CLI is required locally to finish preflight." >&2
  exit 1
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "[preflight] python3 is required to allocate a tunnel port." >&2
  exit 1
fi

# Use SSH tunnel to reach remote PostgreSQL securely.
TUNNEL_PORT="${POSTGRES_PORT}"
if command -v lsof >/dev/null 2>&1 && lsof -Pi :"$TUNNEL_PORT" -sTCP:LISTEN >/dev/null 2>&1; then
  TUNNEL_PORT=$(python3 - <<'PY'
import socket
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind(('127.0.0.1', 0))
    print(s.getsockname()[1])
PY
)
fi

"${SSH_CMD[@]}" -N -L "${TUNNEL_PORT}:${POSTGRES_INTERNAL_HOST}:${POSTGRES_PORT}" "${SSH_USER}@${SSH_HOST}" &
SSH_TUNNEL_PID=$!
trap cleanup EXIT
sleep 1

PGPASSWORD="$POSTGRES_PASSWORD" psql "postgresql://${POSTGRES_USER}@127.0.0.1:${TUNNEL_PORT}/${POSTGRES_DB}?sslmode=disable" \
  --set ON_ERROR_STOP=1 --quiet --command "SELECT 1" >/dev/null

log "PostgreSQL connectivity confirmed."

cat >"$ENV_MIGRATION_FILE" <<ENV
# Autogenerated by scripts/postgres-migration/preflight.sh
SQLITE_PATH=${SQLITE_PATH}
POSTGRES_SSH_HOST=${SSH_HOST}
POSTGRES_SSH_PORT=${SSH_PORT}
POSTGRES_SSH_USER=${SSH_USER}
POSTGRES_SSH_KEY=${SSH_KEY_PATH}
POSTGRES_HOST=${POSTGRES_HOST}
POSTGRES_PORT=${POSTGRES_PORT}
POSTGRES_DB=${POSTGRES_DB}
POSTGRES_USER=${POSTGRES_USER}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
POSTGRES_SUPERUSER=${POSTGRES_SUPERUSER}
POSTGRES_INTERNAL_HOST=${POSTGRES_INTERNAL_HOST}
DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}
ENV

chmod 600 "$ENV_MIGRATION_FILE"
log "Migration environment written to ${ENV_MIGRATION_FILE}."
log "Preflight successful."

